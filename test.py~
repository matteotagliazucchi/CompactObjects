# -*- coding: utf-8 -*-
"""TOV.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yMD2j3Y6TcsykCI59YWiW9WAMW-SPf12

# Solution of TOV equations for a compat star


This Python notebook shows the numerical solution Tolman-Oppenheimer-Volkoff (TOV) that describe equilibrium configurations of nonrotating stars in General Relativity. It also computes the maximum mass for a sequence of stars.

Units: $c=G=M_{\odot}=1$

SB, General Relativity class, FSU Jena WS2018/19

https://bernuzzi.gitlab.io/gr/

# Import some Python library, set constants etc
"""

import numpy as np # for arrays and math
import matplotlib.pyplot as plt # for plotting
from RK4thorder import *

# Conversion factors
LCGS = 1.476701332464468e+05

"""## Equation of state (EOS)

Polytropic model: a simple model for the EOS. Pressure and total energy density are prescribed from the rest-mass density $\rho$ as

$$ P(\rho) = K \rho^\Gamma\\ e = \rho + P/(\Gamma-1) $$

where $(K,\Gamma)$ are two parameters. 

*Question*: What are the physical dimensions of $K$ ?
"""

def EOS_p2erc(p, K=100., Gamma=2.):
  """
  Equation of state (EOS)
  Given pressure, return energy density, rest-mass density and sound speed
  """      
  ene = (p/K)**(1./Gamma) + p/(Gamma-1.)
  rho = (p/K)**(1./Gamma)                       
  cs2 = K*Gamma*(Gamma-1)/(Gamma-1 + K*Gamma*rho**(Gamma-1))*rho**(Gamma-1)
  return ene, rho, cs2

def EOS_r2pe(rho, K=100., Gamma=2.):
  """
  Equation of state (EOS)
  Given rest-mass density, return energy density and pressure
  Polytropic EOS: P = k rho^Gamma
  """
  p = K*rho**Gamma
  e = rho + p/(Gamma-1.);
  return p, e

"""## Tolmann-Oppenheimer-Volkhoff equations"""

def TOV(t, y):
  """
  Tolmann-Oppenheimer-Volkhoff equations
  d/dt y(t) = R.H.S. 
  """
  r = t
  # Unpack state array
  m = y[0] # mass of a sphere of radius r
  p = y[1] # pressure
  # Call the EOS
  ene, dummy1, dummy2 = EOS_p2erc(p) 
  # Set the RHS
  dy = np.empty_like(y)
  dy[0] = 4*np.pi*ene*r**2                               
  dy[1] = -(ene+p)*(m + 4*np.pi*r**3*p)/(r*(r-2*m))
  return dy
  
def found_radius(t, y ,pfloor = 0.):
  """
  Event function: Zero of pressure 
  ODE integration stops when this function returns True
  """
  return ((y[1]-pfloor)<=0.)

"""## The Euler algorithm to solve ODE


The routine below implements a very robust and simple algoirthm for ODE integration.

*Exercise*: Implement a more sophisticated algoriithm like Runge-Kutta or use [SciPy](https://docs.scipy.org/doc/scipy/reference/integrate.html) routine. Verify your results.
"""

def solve_ode_euler(t, y0, dydt_fun, stop_event=None, verbose=False):
  """
  Euler algorithm 
  NOTE: solution is not stored/saved, just return last point
  """
  N = len(t)
  dt = np.diff(t)[0] # assume a uniformly space t array
  y = y0
  for i in range(N):
    yprev = np.copy(y) # store previous for returning pre-event data
    y += dt * dydt_fun(t[i],y)
    if verbose: print(t[i],y)
    if stop_event: 
      if bool(stop_event(t[i],y)): 
        print("Event reached.")
        return t[i-1], yprev 
  if stop_event: print("No event reached")
  return t[i], y

"""## Choose integration parameters

Equations are singular at $r=0$, we need to start at a small radius `rmin`. 

The outer radius of the integration grid `rmax` must be choosen sufficiently large such that $r_\text{max}>R$, where $R$ is  the unknown star radius.
"""

rmin, rmax = 1e-6, 20. 
N = 100 # number of points between rmin and rmax
rspan = np.linspace(rmin,rmax,N)

"""## Initial conditions for a star with $M\sim1.4M_{\odot}$

ODE integration will start at $r\sim0$. The "initial" central pressure is set for a given central rest-mass density value. The initial mass at $r=0$ is $m(0)=0$ but since we start from a positive small radius value we integrate the equation from $r=0$ to $r=$`rmin` (small).

*Exercise:* Convert $\rho$ to CGS units and derive the conversion factor for lengths to km (`LCGS`)

*Exercise:* Derive the equation used in the initial condition for $m(r)$.
"""

rho0 = 1.28e-3 # Central (maximal) rest-mass density
p0,e0 = EOS_r2pe(rho0)
m0    = 4./3.*np.pi*e0*rmin**3
sol0 = [m0, p0]

"""## Solve the IVP for a star with $M\sim1.4M_{\odot}$"""

t, sol = solve_ode_euler(rspan, sol0, TOV, stop_event=found_radius, verbose=True)

# Get mass and radius
R = t * LCGS * 1e-5 # km 
M = sol[0] # Msun
pmin = sol[1]
print(pmin,R,M)

"""## Construct an equilibrium sequence of stars and calculate the maximum mass

*Exercise*  The observed masses of the known neutron stars are summarized in [this paper](https://arxiv.org/abs/1305.3510) 
(see also e.g. https://stellarcollapse.org/nsmasses) Compare the results obtained here with the politropic EOS and those observed. What do you conclude about the EOS model we used?
"""

def set_initial_conditions(rho, rmin):
  """
  Utility routine to set initial data, given rho0
  """
  p,e = EOS_r2pe(rho)
  m    = 4./3.*np.pi*e*rmin**3
  return m, p

# Let us increase the resolution to have better data
N = 1000 # number of points between rmin and rmax
rspan = np.linspace(rmin,rmax,N)

# Build 200 star models
rhospan = np.linspace(0.6e-4,7e-3,200)
R = []
M = []

for rho0 in rhospan:
  # Solve TOV for rho0
  sol0 = set_initial_conditions(rho0, rmin)
  t, sol = solve_ode_euler(rspan, sol0, TOV, stop_event=found_radius)
  R.append(t)
  M.append(sol[0])
  
  
M = np.array(M)
R = np.array(R)

# Find index of maximum mass star
immax = np.argmax(M)
Mmax = M[immax]
Rmax = R[immax]
print(immax,Mmax,Rmax)

km = LCGS * 1e-5
fig = plt.figure()
ax = plt.subplot(111)
plt.title('Mass-Radius diagram for neutron stars')
plt.plot(R*km,M, 'o--', label='NSs', alpha=0.3)
plt.plot(Rmax*km,Mmax, 'ro', label='Maximum mass NS')
ax.legend()
plt.xlabel('$R$ $(km)$')
plt.ylabel('$M$ $(M_\odot)$')
fig.savefig('TOV.png')
plt.show()
